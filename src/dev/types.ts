import { writeFileSync, readFileSync, existsSync } from 'fs';
import { resolve } from 'path';

/**
 * Configuration for deployment services and secrets
 */
export interface DeploymentConfig {
    services?: string[];
    secrets?: string[];
    hasStaticAssets?: boolean;
}

/**
 * KV types as a constant for inline generation (no @cloudflare/workers-types dependency)
 */
const KV_TYPES = `
interface KVNamespace {
  get(key: string, options?: { type?: 'text' }): Promise<string | null>;
  get<T = unknown>(key: string, options: { type: 'json' }): Promise<T | null>;
  get(key: string, options: { type: 'arrayBuffer' }): Promise<ArrayBuffer | null>;
  get(key: string, options: { type: 'stream' }): Promise<ReadableStream | null>;
  
  put(key: string, value: string | ArrayBuffer | ReadableStream, options?: KVNamespacePutOptions): Promise<void>;
  delete(key: string): Promise<void>;
  list(options?: KVNamespaceListOptions): Promise<KVNamespaceListResult>;
}

interface KVNamespacePutOptions {
  expiration?: number;
  expirationTtl?: number;
  metadata?: Record<string, unknown>;
}

interface KVNamespaceListOptions {
  prefix?: string;
  limit?: number;
  cursor?: string;
}

interface KVNamespaceListResult {
  keys: { name: string; expiration?: number; metadata?: Record<string, unknown> }[];
  list_complete: boolean;
  cursor?: string;
}
`;

/**
 * Assets binding type comment - no separate interface needed
 * ASSETS uses inline type { fetch: typeof fetch } matching Cloudflare's definition
 */

/**
 * Generates env.d.ts content from deployment config
 * - Services become typed bindings (e.g., KV: KVNamespace)
 * - Secrets become string properties
 * - ASSETS binding added when static assets are configured
 * - Includes inline KV and Fetcher types (no @cloudflare/workers-types dependency)
 *
 * @param config - Deployment configuration with services and secrets
 * @returns Generated TypeScript declaration content
 */
export function generateEnvTypes(config: DeploymentConfig): string {
    const lines: string[] = [
        '// env.d.ts',
        '// AUTO-GENERATED by Bkper CLI from bkper.yaml',
        '// Regenerate with: bkper app build',
        '',
        'export interface Env {',
    ];

    const hasServices = config.services && config.services.length > 0;
    const hasSecrets = config.secrets && config.secrets.length > 0;
    const hasKV = config.services?.includes('KV');
    const hasStaticAssets = config.hasStaticAssets === true;

    // Add services section
    if (hasServices) {
        lines.push('  // Services');
        for (const service of config.services!) {
            if (service === 'KV') {
                lines.push('  KV: KVNamespace;');
            }
            // Add more services as needed
        }
    }

    // Add static assets binding
    if (hasStaticAssets) {
        if (hasServices) {
            lines.push('');
        }
        lines.push('  // Static assets binding');
        lines.push('  ASSETS: { fetch: typeof fetch };');
    }

    // Add secrets section
    if (hasSecrets) {
        if (hasServices || hasStaticAssets) {
            lines.push('');
        }
        lines.push('  // Secrets');
        for (const secret of config.secrets!) {
            lines.push(`  ${secret}: string;`);
        }
    }

    lines.push('}');

    // Add KV types if KV service is used
    if (hasKV) {
        lines.push('');
        lines.push('// KV types (inline, no external dependency)');
        lines.push(KV_TYPES.trim());
    }

    return lines.join('\n') + '\n';
}

/**
 * Converts a secret name to a placeholder value
 * Example: API_KEY -> your-api-key-here
 *
 * @param secretName - The secret name in SCREAMING_SNAKE_CASE
 * @returns Placeholder value in kebab-case
 */
function secretNameToPlaceholder(secretName: string): string {
    const kebab = secretName.toLowerCase().replace(/_/g, '-');
    return `your-${kebab}-here`;
}

/**
 * Generates .dev.vars.example content from secrets list
 * - Creates template with placeholder values
 * - Includes helpful comments
 *
 * @param secrets - List of secret names
 * @returns Generated .dev.vars.example content
 */
export function generateDevVarsExample(secrets: string[]): string {
    const lines: string[] = [
        '# .dev.vars.example',
        '# Copy this file to .dev.vars and fill in your local development values',
        '# .dev.vars is gitignored and used by the Bkper CLI for local development',
        '',
    ];

    for (const secret of secrets) {
        lines.push(`${secret}=${secretNameToPlaceholder(secret)}`);
    }

    return lines.join('\n') + '\n';
}

/**
 * Parses a .dev.vars file content into key-value pairs
 * Handles comments, empty lines, and values with equals signs
 *
 * @param content - The file content to parse
 * @returns Record of key-value pairs
 */
function parseDevVars(content: string): Record<string, string> {
    const result: Record<string, string> = {};

    for (const line of content.split('\n')) {
        const trimmed = line.trim();

        // Skip empty lines and comments
        if (!trimmed || trimmed.startsWith('#')) {
            continue;
        }

        // Split on first equals sign only
        const equalsIndex = trimmed.indexOf('=');
        if (equalsIndex === -1) {
            continue;
        }

        const key = trimmed.substring(0, equalsIndex);
        const value = trimmed.substring(equalsIndex + 1);
        result[key] = value;
    }

    return result;
}

/**
 * Loads .dev.vars file and returns key-value pairs
 * - Warns about missing secrets but doesn't block
 * - Returns empty object if file doesn't exist
 *
 * @param projectRoot - Path to the project root
 * @param requiredSecrets - List of required secret names
 * @returns Record of secret name to value
 */
export function loadDevVars(
    projectRoot: string,
    requiredSecrets: string[]
): Record<string, string> {
    const devVarsPath = resolve(projectRoot, '.dev.vars');

    if (!existsSync(devVarsPath)) {
        return {};
    }

    const content = readFileSync(devVarsPath, 'utf8');
    const vars = parseDevVars(content);

    // Check for missing secrets
    for (const secret of requiredSecrets) {
        if (!(secret in vars)) {
            console.warn(
                `Warning: Missing secret '${secret}' in .dev.vars. ` +
                    `Copy .dev.vars.example to .dev.vars and fill in the values.`
            );
        }
    }

    return vars;
}

/**
 * Ensures types are up to date with bkper.yaml
 * - Compares existing files with generated content
 * - Warns and updates if mismatch detected
 * - Creates files if they don't exist
 *
 * @param config - Deployment configuration
 * @param projectRoot - Path to the project root
 */
export function ensureTypesUpToDate(config: DeploymentConfig, projectRoot: string): void {
    const envDtsPath = resolve(projectRoot, 'env.d.ts');
    const devVarsExamplePath = resolve(projectRoot, '.dev.vars.example');

    // Generate expected content
    const expectedEnvTypes = generateEnvTypes(config);

    // Check and update env.d.ts
    if (existsSync(envDtsPath)) {
        const existingContent = readFileSync(envDtsPath, 'utf8');
        if (existingContent !== expectedEnvTypes) {
            console.warn('Warning: env.d.ts is out of sync with bkper.yaml. Updating...');
            writeFileSync(envDtsPath, expectedEnvTypes);
        }
    } else {
        writeFileSync(envDtsPath, expectedEnvTypes);
    }

    // Only create .dev.vars.example if there are secrets
    const hasSecrets = config.secrets && config.secrets.length > 0;
    if (hasSecrets) {
        const expectedDevVarsExample = generateDevVarsExample(config.secrets!);

        if (existsSync(devVarsExamplePath)) {
            const existingContent = readFileSync(devVarsExamplePath, 'utf8');
            if (existingContent !== expectedDevVarsExample) {
                console.warn(
                    'Warning: .dev.vars.example is out of sync with bkper.yaml. Updating...'
                );
                writeFileSync(devVarsExamplePath, expectedDevVarsExample);
            }
        } else {
            writeFileSync(devVarsExamplePath, expectedDevVarsExample);
        }
    }
}
