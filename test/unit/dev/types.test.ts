import { expect, setupTestEnvironment, getTestPaths } from '../helpers/test-setup.js';
import fs from 'fs';
import path from 'path';

const { __dirname } = getTestPaths(import.meta.url);

// Temp directory for test files
const testDir = path.join(__dirname, '../fixtures/temp-types-test');

// Import the functions to test
let generateEnvTypes: typeof import('../../../src/dev/types.js').generateEnvTypes;
let generateDevVarsExample: typeof import('../../../src/dev/types.js').generateDevVarsExample;
let loadDevVars: typeof import('../../../src/dev/types.js').loadDevVars;
let ensureTypesUpToDate: typeof import('../../../src/dev/types.js').ensureTypesUpToDate;

describe('Types Generation Module', function() {
    before(async function() {
        const types = await import('../../../src/dev/types.js');
        generateEnvTypes = types.generateEnvTypes;
        generateDevVarsExample = types.generateDevVarsExample;
        loadDevVars = types.loadDevVars;
        ensureTypesUpToDate = types.ensureTypesUpToDate;
    });

    beforeEach(function() {
        setupTestEnvironment();
        // Create temp directory
        fs.mkdirSync(testDir, { recursive: true });
    });

    afterEach(function() {
        // Cleanup temp directory
        if (fs.existsSync(testDir)) {
            fs.rmSync(testDir, { recursive: true });
        }
    });

    describe('generateEnvTypes', function() {
        it('should generate types with KV service only', function() {
            const config = {
                services: ['KV']
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('export interface Env');
            expect(result).to.include('KV: KVNamespace');
            expect(result).to.include('interface KVNamespace');
            expect(result).to.include('AUTO-GENERATED by Bkper CLI');
            expect(result).not.to.include('// Secrets');
        });

        it('should generate types with secrets only', function() {
            const config = {
                secrets: ['API_KEY', 'WEBHOOK_URL']
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('export interface Env');
            expect(result).to.include('API_KEY: string');
            expect(result).to.include('WEBHOOK_URL: string');
            expect(result).to.include('// Secrets');
            expect(result).not.to.include('KV: KVNamespace');
            expect(result).not.to.include('// Services');
        });

        it('should generate types with both services and secrets', function() {
            const config = {
                services: ['KV'],
                secrets: ['API_KEY', 'WEBHOOK_URL']
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('export interface Env');
            expect(result).to.include('// Services');
            expect(result).to.include('KV: KVNamespace');
            expect(result).to.include('// Secrets');
            expect(result).to.include('API_KEY: string');
            expect(result).to.include('WEBHOOK_URL: string');
            expect(result).to.include('interface KVNamespace');
        });

        it('should generate empty Env interface with empty config', function() {
            const config = {};

            const result = generateEnvTypes(config);

            expect(result).to.include('export interface Env');
            expect(result).to.include('AUTO-GENERATED by Bkper CLI');
            // Should not have services or secrets sections
            expect(result).not.to.include('// Services');
            expect(result).not.to.include('// Secrets');
        });

        it('should include KV helper types when KV service is present', function() {
            const config = {
                services: ['KV']
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('interface KVNamespace');
            expect(result).to.include('get(key: string');
            expect(result).to.include('put(key: string');
            expect(result).to.include('delete(key: string');
            expect(result).to.include('list(options?');
            expect(result).to.include('interface KVNamespacePutOptions');
            expect(result).to.include('interface KVNamespaceListOptions');
            expect(result).to.include('interface KVNamespaceListResult');
        });

        it('should include ASSETS binding when hasStaticAssets is true', function() {
            const config = {
                hasStaticAssets: true
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('export interface Env');
            expect(result).to.include('ASSETS: { fetch: typeof fetch }');
            expect(result).not.to.include('interface Fetcher');
        });

        it('should include ASSETS binding alongside services and secrets', function() {
            const config = {
                services: ['KV'],
                secrets: ['API_KEY'],
                hasStaticAssets: true
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('KV: KVNamespace');
            expect(result).to.include('API_KEY: string');
            expect(result).to.include('ASSETS: { fetch: typeof fetch }');
            expect(result).to.include('interface KVNamespace');
            expect(result).not.to.include('interface Fetcher');
        });

        it('should not include ASSETS binding when hasStaticAssets is false', function() {
            const config = {
                services: ['KV'],
                hasStaticAssets: false
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('KV: KVNamespace');
            expect(result).not.to.include('ASSETS:');
        });

        it('should not include ASSETS binding when hasStaticAssets is not provided', function() {
            const config = {
                services: ['KV']
            };

            const result = generateEnvTypes(config);

            expect(result).to.include('KV: KVNamespace');
            expect(result).not.to.include('ASSETS:');
        });
    });

    describe('generateDevVarsExample', function() {
        it('should generate example with multiple secrets', function() {
            const secrets = ['API_KEY', 'WEBHOOK_URL', 'SECRET_TOKEN'];

            const result = generateDevVarsExample(secrets);

            expect(result).to.include('# .dev.vars.example');
            expect(result).to.include('Copy this file to .dev.vars');
            expect(result).to.include('API_KEY=your-api-key-here');
            expect(result).to.include('WEBHOOK_URL=your-webhook-url-here');
            expect(result).to.include('SECRET_TOKEN=your-secret-token-here');
        });

        it('should generate minimal content with empty array', function() {
            const secrets: string[] = [];

            const result = generateDevVarsExample(secrets);

            expect(result).to.include('# .dev.vars.example');
            expect(result).to.include('Copy this file to .dev.vars');
            // Should not have any secret placeholders
            expect(result).not.to.include('=your-');
        });

        it('should convert secret names to placeholder format', function() {
            const secrets = ['MY_SECRET_KEY'];

            const result = generateDevVarsExample(secrets);

            expect(result).to.include('MY_SECRET_KEY=your-my-secret-key-here');
        });
    });

    describe('loadDevVars', function() {
        it('should load key-value pairs from valid .dev.vars file', function() {
            const devVarsContent = `API_KEY=test-api-key
WEBHOOK_URL=https://example.com/webhook
SECRET_TOKEN=abc123`;
            fs.writeFileSync(path.join(testDir, '.dev.vars'), devVarsContent);

            const result = loadDevVars(testDir, ['API_KEY', 'WEBHOOK_URL', 'SECRET_TOKEN']);

            expect(result).to.deep.equal({
                API_KEY: 'test-api-key',
                WEBHOOK_URL: 'https://example.com/webhook',
                SECRET_TOKEN: 'abc123'
            });
        });

        it('should return empty object when .dev.vars file does not exist', function() {
            const result = loadDevVars(testDir, ['API_KEY']);

            expect(result).to.deep.equal({});
        });

        it('should warn about missing secrets but not block', function() {
            const devVarsContent = `API_KEY=test-api-key`;
            fs.writeFileSync(path.join(testDir, '.dev.vars'), devVarsContent);

            const consoleWarnings: string[] = [];
            const originalWarn = console.warn;
            console.warn = (...args: unknown[]) => consoleWarnings.push(args.join(' '));

            try {
                const result = loadDevVars(testDir, ['API_KEY', 'MISSING_SECRET']);

                expect(result).to.deep.equal({
                    API_KEY: 'test-api-key'
                });
                expect(consoleWarnings.some(w => w.includes('MISSING_SECRET'))).to.be.true;
            } finally {
                console.warn = originalWarn;
            }
        });

        it('should handle comments and empty lines in .dev.vars', function() {
            const devVarsContent = `# This is a comment
API_KEY=test-key

# Another comment
WEBHOOK_URL=https://example.com`;
            fs.writeFileSync(path.join(testDir, '.dev.vars'), devVarsContent);

            const result = loadDevVars(testDir, ['API_KEY', 'WEBHOOK_URL']);

            expect(result).to.deep.equal({
                API_KEY: 'test-key',
                WEBHOOK_URL: 'https://example.com'
            });
        });

        it('should handle values with equals signs', function() {
            const devVarsContent = `API_KEY=key=with=equals`;
            fs.writeFileSync(path.join(testDir, '.dev.vars'), devVarsContent);

            const result = loadDevVars(testDir, ['API_KEY']);

            expect(result).to.deep.equal({
                API_KEY: 'key=with=equals'
            });
        });
    });

    describe('ensureTypesUpToDate', function() {
        it('should create env.d.ts if it does not exist', function() {
            const config = {
                services: ['KV'],
                secrets: ['API_KEY']
            };

            ensureTypesUpToDate(config, testDir);

            const envDtsPath = path.join(testDir, 'env.d.ts');
            expect(fs.existsSync(envDtsPath)).to.be.true;

            const content = fs.readFileSync(envDtsPath, 'utf8');
            expect(content).to.include('KV: KVNamespace');
            expect(content).to.include('API_KEY: string');
        });

        it('should create .dev.vars.example if it does not exist', function() {
            const config = {
                secrets: ['API_KEY', 'WEBHOOK_URL']
            };

            ensureTypesUpToDate(config, testDir);

            const devVarsExamplePath = path.join(testDir, '.dev.vars.example');
            expect(fs.existsSync(devVarsExamplePath)).to.be.true;

            const content = fs.readFileSync(devVarsExamplePath, 'utf8');
            expect(content).to.include('API_KEY=your-api-key-here');
            expect(content).to.include('WEBHOOK_URL=your-webhook-url-here');
        });

        it('should warn and update env.d.ts if content differs', function() {
            const config = {
                services: ['KV'],
                secrets: ['API_KEY']
            };

            // Create outdated env.d.ts
            const outdatedContent = '// Old content\nexport interface Env {}';
            fs.writeFileSync(path.join(testDir, 'env.d.ts'), outdatedContent);

            const consoleWarnings: string[] = [];
            const originalWarn = console.warn;
            console.warn = (...args: unknown[]) => consoleWarnings.push(args.join(' '));

            try {
                ensureTypesUpToDate(config, testDir);

                // Should have warned about mismatch
                expect(consoleWarnings.some(w => w.includes('env.d.ts'))).to.be.true;

                // Should have updated the file
                const content = fs.readFileSync(path.join(testDir, 'env.d.ts'), 'utf8');
                expect(content).to.include('KV: KVNamespace');
                expect(content).to.include('API_KEY: string');
            } finally {
                console.warn = originalWarn;
            }
        });

        it('should not warn if env.d.ts content matches', function() {
            const config = {
                services: ['KV'],
                secrets: ['API_KEY']
            };

            // First run to create the file
            ensureTypesUpToDate(config, testDir);

            const consoleWarnings: string[] = [];
            const originalWarn = console.warn;
            console.warn = (...args: unknown[]) => consoleWarnings.push(args.join(' '));

            try {
                // Second run should not warn
                ensureTypesUpToDate(config, testDir);

                expect(consoleWarnings.filter(w => w.includes('env.d.ts'))).to.have.length(0);
            } finally {
                console.warn = originalWarn;
            }
        });

        it('should handle config with no secrets (no .dev.vars.example created)', function() {
            const config = {
                services: ['KV']
            };

            ensureTypesUpToDate(config, testDir);

            // env.d.ts should exist
            expect(fs.existsSync(path.join(testDir, 'env.d.ts'))).to.be.true;

            // .dev.vars.example should not exist (no secrets to template)
            expect(fs.existsSync(path.join(testDir, '.dev.vars.example'))).to.be.false;
        });
    });
});
